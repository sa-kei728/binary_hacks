# ライブラリ

## 静的ライブラリ

arコマンドによって複数のオブジェクトファイルを1つのアーカイブファイルを生成.  
OSによってはranlibを使うことで, アーカイブ内のオブジェクトが提供するシンボル情報のハッシュを作成し,  
アーカイブからシンボルを提供しているオブジェクトファイルの検索を効率よく行うこともある.  

|arコマンドオプション|内容|
|:---:|:---|
|r|メンバ追加. 指定したアーカイブファイルにメンバを追加する|
|D|deterministic modeを有効化(アーカイブファイル内のファイル/タイムスタンプ情報を0で設定)|
|U|deterministic modeを無効化.|
|u|アーカイブ内のメンバと追加ファイルのタイムスタンプを比較して, ファイルを更新.deterministic mode OFFである必要あり|
|v|verboseモード|
|t|アーカイブの内容確認|

```console
$ cc -c -o foo.o foo.c
$ cc -c -o bar.o bar.c 
$ ar rUuv libfoo.a foo.o bar.o
ar: `u' modifier ignored since `D' is the default (see `U')
ar: libfoo.a を作成しています
a - foo.o
a - bar.o

$ ar tv libfoo.a 
rw-rw-r-- 1000/1000   1224 Mar  4 18:02 2022 foo.o
rw-rw-r-- 1000/1000   1224 Mar  4 18:02 2022 bar.o
```

実際にリンクする場合には下記で対応. 実行時にはライブラリは不要.
```
$ cc -o main main.o -L. -lfoo
```

## 共有ライブラリ

共有ライブラリは仮想メモリシステムを活用し, mmapなどによって複数プロセスでメモリを共有して参照できるようになり,これを有効活用したもの.  
今のOSではメモリマップだけ設定して, 実際にはメモリ内容が参照されるまでディスクアクセスを遅延可能(おそらくデマンドページングのこと)なので,  
巨大オブジェクトでも問題が少なくなってきている.  
共有ライブラリ作成時はオブジェクトファイルにfPIC(PositionIndependentCode)を付けることが多い.  
これはPLTを参照するために実行時再配置が早く, 他プロセスと.textを共有できるため.  

実際に.soファイルを作るときは-sharedを付けて共有オブジェクトを作成,  
-Wl,-sonameでリンカにその共有オブジェクトに指定したSONAMEを指定しておき,このSONAMEによってどの共有オブジェクトを実行時にリンクするかを決定可能.  
```
$ cc -fPIC -c -o foo.o foo.c
$ cc -fPIC -c -o bar.o bar.c
$ cc -shared -Wl,-soname,libfoo.so.0 -o libfoo.so foo.o bar.o
```

実際にリンクする場合には下記で対応.
```
$ cc -o main main.o -L. -lfoo
```

この実行ファイルには未定義シンボルに対してNEEDEDに共有オブジェクトをSONAMEに設定をするだけでコード自体はコピーしない.  
また, .soにはどのようなオブジェクトファイルがあるかは残らない.

### それぞれの比較

|カテゴリ|静的ライブラリ|動的ライブラリ|
|:---:|:---|:---|
|ファイルサイズ|コードがコピーされるので容量が増える.同じコードを使う実行ファイルが多いと損.|同じライブラリ利用ファイルがあっても1つのライブラリで済む|
|メモリサイズ|容量が増えるので使用量も増える.|PICを付けておくと再配置不要なためメモリも損しない.|
|パッチ対応|ライブラリだけでなく実行バイナリも作り直し.|ライブラリを変えるだけで済む.既に実行しているプログラムはプロセス再起動が必要.|
